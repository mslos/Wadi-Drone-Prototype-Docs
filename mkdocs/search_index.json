{
    "docs": [
        {
            "location": "/", 
            "text": "Wadi Drone Prototype Build Documentation\n\n\nFor a brief introduction to the project visit \nwadi.io\n.\n\n\nAbout this documentation\n\n\nWadi Drone was a prototype of a \"data mule\" (\nM\nobile \nU\nbiquitous \nL\nAN \nE\nxtension), created by an undergraduate research group at NYU Abu Dhabi. This documentation captures many lessons that we learned in creating our prototype (for example work with XBees, Sleepy Pi platform and Raspberry Pi). It includes graphics that we created for your inspiration. We would like to share this knowledge with the world since much of the work was based on open source hardware and software. \n\n\nWadi Drone transmission system can work with any platform that supports Pixhawk flight controller, whether it is a plane or a quadcopter. The prototype is essentially a box that could be loaded on any aerial platform and work as a data mule. All the tutorials are available under MIT License without any guarantees.\n\n\n\n\nOperation of a data mule\n\n\nThe below schematic shows the target state operation. In the prototype, we did not achieve full functionality of the system, mainly due to reliability concerns. However, \nMission Mule\n, a company that picked up this project, has made the full version a reality.\n\n\n\n\nMIT License\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this hardware, software, and associated documentation files (the \"Product\"), to deal in the Product without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Product, and to permit persons to whom the Product is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Product.\n\n\nTHE PRODUCT IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE PRODUCT OR THE USE OR OTHER DEALINGS IN THE PRODUCT.", 
            "title": "About (Read First)"
        }, 
        {
            "location": "/#wadi-drone-prototype-build-documentation", 
            "text": "For a brief introduction to the project visit  wadi.io .", 
            "title": "Wadi Drone Prototype Build Documentation"
        }, 
        {
            "location": "/#about-this-documentation", 
            "text": "Wadi Drone was a prototype of a \"data mule\" ( M obile  U biquitous  L AN  E xtension), created by an undergraduate research group at NYU Abu Dhabi. This documentation captures many lessons that we learned in creating our prototype (for example work with XBees, Sleepy Pi platform and Raspberry Pi). It includes graphics that we created for your inspiration. We would like to share this knowledge with the world since much of the work was based on open source hardware and software.   Wadi Drone transmission system can work with any platform that supports Pixhawk flight controller, whether it is a plane or a quadcopter. The prototype is essentially a box that could be loaded on any aerial platform and work as a data mule. All the tutorials are available under MIT License without any guarantees.", 
            "title": "About this documentation"
        }, 
        {
            "location": "/#operation-of-a-data-mule", 
            "text": "The below schematic shows the target state operation. In the prototype, we did not achieve full functionality of the system, mainly due to reliability concerns. However,  Mission Mule , a company that picked up this project, has made the full version a reality.", 
            "title": "Operation of a data mule"
        }, 
        {
            "location": "/#mit-license", 
            "text": "Permission is hereby granted, free of charge, to any person obtaining a copy of this hardware, software, and associated documentation files (the \"Product\"), to deal in the Product without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Product, and to permit persons to whom the Product is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Product.  THE PRODUCT IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE PRODUCT OR THE USE OR OTHER DEALINGS IN THE PRODUCT.", 
            "title": "MIT License"
        }, 
        {
            "location": "/overview/", 
            "text": "Overview\n\n\nThis portion of the documentation gives a brief overview of the physical circuits and circuit diagrams representing said circuits. This section is a reference for further tutorials, and can be used to verify circuits later on. Furthermore, the hardware presented in the table below may be purchased for constructing your own Wadi Drone. \n\n\nThe diagram below is the overview of the whole Wadi Drone system. This part of the guide will walk you through the set-up of the photo-communication system. The overview for the photo-communication system is shown in the diagram below.\n\n\n\n\nComponents Needed\n\n\n\n\n\n\n\n\nComponent\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\n2 Watt Solar Charger Kit\n\n\n1\n\n\n\n\n\n\nUSB / DC / Solar Lithium Ion/Polymer charger - v2\n\n\n1\n\n\n\n\n\n\n2.4GHz Dipole Swivel Antenna with RP-SMA - 5dBi\n\n\n2\n\n\n\n\n\n\nUSB WiFi (802.11b/g/n) Module with Antenna for Raspberry Pi\n\n\n2\n\n\n\n\n\n\nLithium Ion Battery Pack - 3.7V 4400mAh\n\n\n1\n\n\n\n\n\n\nXBee Pro 60mW Wire Antenna - Series 1 (802.15.4)\n\n\n2\n\n\n\n\n\n\nXBee Pro 60mW U.FL Connection - Series 1 (802.15.4)\n\n\n2\n\n\n\n\n\n\nRP-SMA to uFL/u.FL/IPX/IPEX RF Adapter Cable\n\n\n2\n\n\n\n\n\n\nDC Barrel Jack Plug - Male\n\n\n4\n\n\n\n\n\n\nRaspberry Pi - Model B+\n\n\n2\n\n\n\n\n\n\nSD Card - 8GB - SanDisk Ultra microSDHC UHS-I Card with Adapter\n\n\n2\n\n\n\n\n\n\nLithium Ion Battery Pack - 3.7V 6600mAh\n\n\n2\n\n\n\n\n\n\nPowerBoost 1000 Basic - 5V USB Boost @1000mA from 1.8V\n\n\n2\n\n\n\n\n\n\nSleepy Pi\n\n\n1\n\n\n\n\n\n\nSparkFun XBee Explorer Regulated\n\n\n2\n\n\n\n\n\n\n\n\nDrone Transmission System Circuit\n\n\nDrone circuit\n\n\nPhysical circuit of transmission system located on the drone.\n\n\n\n\nDrone circuit diagram\n\n\nWiring diagram for the the drone transmission system.\n\n\n\n\nDrone power circuit\n\n\nPhysical circuit of power system located on the drone.\n\n\n\n\nCamera Trap Transmission System Circuit\n\n\nCamera Trap circuit\n\n\nPhysical circuit of transmission system located on the camera trap.\n\n\n\n\nCamera Trap circuit diagram\n\n\nWiring diagram for the the camera trap transmission system.\n\n\n\n\nCamera Trap power circuit\n\n\nPhysical circuit of power system located on the camera trap.", 
            "title": "Circuits and bills of material"
        }, 
        {
            "location": "/overview/#overview", 
            "text": "This portion of the documentation gives a brief overview of the physical circuits and circuit diagrams representing said circuits. This section is a reference for further tutorials, and can be used to verify circuits later on. Furthermore, the hardware presented in the table below may be purchased for constructing your own Wadi Drone.   The diagram below is the overview of the whole Wadi Drone system. This part of the guide will walk you through the set-up of the photo-communication system. The overview for the photo-communication system is shown in the diagram below.", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/#components-needed", 
            "text": "Component  Quantity      2 Watt Solar Charger Kit  1    USB / DC / Solar Lithium Ion/Polymer charger - v2  1    2.4GHz Dipole Swivel Antenna with RP-SMA - 5dBi  2    USB WiFi (802.11b/g/n) Module with Antenna for Raspberry Pi  2    Lithium Ion Battery Pack - 3.7V 4400mAh  1    XBee Pro 60mW Wire Antenna - Series 1 (802.15.4)  2    XBee Pro 60mW U.FL Connection - Series 1 (802.15.4)  2    RP-SMA to uFL/u.FL/IPX/IPEX RF Adapter Cable  2    DC Barrel Jack Plug - Male  4    Raspberry Pi - Model B+  2    SD Card - 8GB - SanDisk Ultra microSDHC UHS-I Card with Adapter  2    Lithium Ion Battery Pack - 3.7V 6600mAh  2    PowerBoost 1000 Basic - 5V USB Boost @1000mA from 1.8V  2    Sleepy Pi  1    SparkFun XBee Explorer Regulated  2", 
            "title": "Components Needed"
        }, 
        {
            "location": "/overview/#drone-transmission-system-circuit", 
            "text": "Drone circuit  Physical circuit of transmission system located on the drone.   Drone circuit diagram  Wiring diagram for the the drone transmission system.   Drone power circuit  Physical circuit of power system located on the drone.", 
            "title": "Drone Transmission System Circuit"
        }, 
        {
            "location": "/overview/#camera-trap-transmission-system-circuit", 
            "text": "Camera Trap circuit  Physical circuit of transmission system located on the camera trap.   Camera Trap circuit diagram  Wiring diagram for the the camera trap transmission system.   Camera Trap power circuit  Physical circuit of power system located on the camera trap.", 
            "title": "Camera Trap Transmission System Circuit"
        }, 
        {
            "location": "/hardware/", 
            "text": "Hardware Preparation\n\n\nIn order to begin installing Wadi Drone components you must prepare the hardware and install all the necessary prerequisites.\n\n\nRaspberry Pi\n\n\nThis guide uses Raspberry Pi with Raspbian installed. \u2018Noobs\u2019 is the easiest way to install Raspbian on Raspberry Pi. Use the \nfollowing link\n for a set up guide on how to install Raspbian using \"Noobs\". An SD Card of 8GB or more is recommended.\n\n\nWhen the installation process is complete the Raspberry Pi configuration menu appears. It is not necessary to configure anything specific to Wadi Drone at this point. Click Finish and the terminal comes up.\n\n\nIn the terminal enter \nstartx\n to open GUI mode of the operating system. From here open Menu \n Preferences \n WiFi Configure to connect to wifi. Make sure your USB Wifi module for Raspberry Pi is connected to one of the USB ports. Alternatively, use an Ethernet cable to connect to the internet.\n\n\nIt\u2019s a good idea to ensure that your Raspbian is up to date by opening up an LXTerminal window and executing the following:\n\n\n$ sudo apt-get update\n$ sudo apt-get dist-upgrade\n\n\n\n\nXBee\n\n\nThe two Xbees must be pre-configured to communicate with each other. The \nfollowing guide\n worked well with the Xbees used in the prototype. The Xbees can be configured from any computer.\n\n\nBelow is a brief summary of the guide.\n\n\n\n\nDownload \nCoolTerm by Roger Meier\n. Below is the standard CoolTerm GUI window.\n\n\n\n\n\n\n\n\n\n\nAfter opening CoolTerm click \"Options\".\n\n\n\n\n\n\nChoose the serial port that starts with \"usbserial\". If you cannot see the serial port, click on \"Re-Scan Serial Ports.\" If you\u2019re not sure which serial port to select, look at the list of available ports and then disconnect the \nXBee Explorer\n from your computer. Click \u201cRe-Scan Serial Ports\u201d and check which serial port disappeared. Reconnect your \nXBee Explorer\n, click \u201cRe-Scan Serial Ports\u201d and choose that port.\n\n\n\n\n\n\nBe sure Baudrate is set to 9600.\n\n\n\n\n\n\nBe sure Data Bits is set to 8.\n\n\n\n\n\n\nBe sure Parity is set to \"none\".\n\n\n\n\n\n\nBe sure Stop Bits is set to 1.\n\n\n\n\n\n\nIn the list on the left side of the options window, click \u201cTerminal\u201d.\n\n\n\n\n\n\nBe sure \u201cLocal Echo\u201d is activated. This will allow you to see what you\u2019re typing into the terminal.\n\n\n\n\n\n\nClick OK to save those settings and close the Options window.\n\n\n\n\n\n\nClick \"Connect\" in the toolbar.\n\n\n\n\n\n\nYou should see \"Connected\" in the status bar at the bottom of the window.\n\n\n\n\n\n\nType \"+++\" to enter command mode. You should see the reply \"OK\". Below are the settings that we use.\n\n\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\nCommand\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nPAN ID\n\n\nATID\n\n\n3001\n (any address from 0 to FFFE will do)\n\n\n\n\n\n\nMY Address\n\n\nATMY\n\n\n1\n\n\n\n\n\n\nDestination address high\n\n\nATDH\n\n\n0\n (indicates 1 16-bit address)\n\n\n\n\n\n\nDestination address low\n\n\nATDL\n\n\n2\n\n\n\n\n\n\n\n\n\n\n\n\nType in each command followed by its parameter and hit enter. If the XBee does not respond, it might have timed out, so just type \"+++\" and start all over again.\n\n\n\n\n\n\nYou can verify the setting by typing the command without a parameter.\n\n\n\n\n\n\nYour settings aren\u2019t saved yet! Type \nATWR\n to save the settings.\n\n\n\n\n\n\nHere\u2019s how the terminal session will look, starting with the \u201c+++\u201d to enter command mode. Note that in the second half of the session, we check what the settings are and then we confirm the changes with \nATWR\n.\n\n\n\n\n\n\n\n\n\n\n\n\nNow you can configure the second XBee. Mark the second Xbee with a \"B\".\n\n\n\n\n\n\nPlace the XBee into the XBee Explorer and click \u201cConnect\u201d in CoolTerm.\n\n\n\n\n\n\nFollow the same steps as before to program the second radio. However, ATMY gets 2 and the ATDL gets 1. See the chart below.\n\n\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\nCommand\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nPAN ID\n\n\nATID\n\n\n3001\n (any address from 0 to FFFE will do)\n\n\n\n\n\n\nMY Address\n\n\nATMY\n\n\n2\n\n\n\n\n\n\nDestination address high\n\n\nATDH\n\n\n0\n (indicates 1 16-bit address)\n\n\n\n\n\n\nDestination address low\n\n\nATDL\n\n\n1\n\n\n\n\n\n\n\n\n\n\n\n\nRemember to type \nATWR\n and press enter to save the settings.\n\n\n\n\n\n\nHere's a sample of what a terminal looks like after taking these steps.\n\n\n\n\n\n\n\n\nSleepy Pi\n\n\nThe transmission device connected to the camera trap requires \nSleepy Pi\n for reducing power consumption. Sleepy Pi sits on top of the Raspberry Pi B+ as shown in the photo below.\n\n\n\n\nThe Sleepy Pi does not need a coin cell battery because we are not using Sleepy Pi's clock in the current version of the system.\n\n\n\n\nYou should put electric tape on the connectors of the Raspberry Pi to avoid short-circuiting Sleepy Pi. In general, Sleepy Pi is liable to short circuits, which can destroy the piece of hardware, so you should exert extra caution when working with the board.", 
            "title": "Hardware preparation"
        }, 
        {
            "location": "/hardware/#hardware-preparation", 
            "text": "In order to begin installing Wadi Drone components you must prepare the hardware and install all the necessary prerequisites.", 
            "title": "Hardware Preparation"
        }, 
        {
            "location": "/hardware/#raspberry-pi", 
            "text": "This guide uses Raspberry Pi with Raspbian installed. \u2018Noobs\u2019 is the easiest way to install Raspbian on Raspberry Pi. Use the  following link  for a set up guide on how to install Raspbian using \"Noobs\". An SD Card of 8GB or more is recommended.  When the installation process is complete the Raspberry Pi configuration menu appears. It is not necessary to configure anything specific to Wadi Drone at this point. Click Finish and the terminal comes up.  In the terminal enter  startx  to open GUI mode of the operating system. From here open Menu   Preferences   WiFi Configure to connect to wifi. Make sure your USB Wifi module for Raspberry Pi is connected to one of the USB ports. Alternatively, use an Ethernet cable to connect to the internet.  It\u2019s a good idea to ensure that your Raspbian is up to date by opening up an LXTerminal window and executing the following:  $ sudo apt-get update\n$ sudo apt-get dist-upgrade", 
            "title": "Raspberry Pi"
        }, 
        {
            "location": "/hardware/#xbee", 
            "text": "The two Xbees must be pre-configured to communicate with each other. The  following guide  worked well with the Xbees used in the prototype. The Xbees can be configured from any computer.  Below is a brief summary of the guide.   Download  CoolTerm by Roger Meier . Below is the standard CoolTerm GUI window.      After opening CoolTerm click \"Options\".    Choose the serial port that starts with \"usbserial\". If you cannot see the serial port, click on \"Re-Scan Serial Ports.\" If you\u2019re not sure which serial port to select, look at the list of available ports and then disconnect the  XBee Explorer  from your computer. Click \u201cRe-Scan Serial Ports\u201d and check which serial port disappeared. Reconnect your  XBee Explorer , click \u201cRe-Scan Serial Ports\u201d and choose that port.    Be sure Baudrate is set to 9600.    Be sure Data Bits is set to 8.    Be sure Parity is set to \"none\".    Be sure Stop Bits is set to 1.    In the list on the left side of the options window, click \u201cTerminal\u201d.    Be sure \u201cLocal Echo\u201d is activated. This will allow you to see what you\u2019re typing into the terminal.    Click OK to save those settings and close the Options window.    Click \"Connect\" in the toolbar.    You should see \"Connected\" in the status bar at the bottom of the window.    Type \"+++\" to enter command mode. You should see the reply \"OK\". Below are the settings that we use.       Function  Command  Parameter      PAN ID  ATID  3001  (any address from 0 to FFFE will do)    MY Address  ATMY  1    Destination address high  ATDH  0  (indicates 1 16-bit address)    Destination address low  ATDL  2       Type in each command followed by its parameter and hit enter. If the XBee does not respond, it might have timed out, so just type \"+++\" and start all over again.    You can verify the setting by typing the command without a parameter.    Your settings aren\u2019t saved yet! Type  ATWR  to save the settings.    Here\u2019s how the terminal session will look, starting with the \u201c+++\u201d to enter command mode. Note that in the second half of the session, we check what the settings are and then we confirm the changes with  ATWR .       Now you can configure the second XBee. Mark the second Xbee with a \"B\".    Place the XBee into the XBee Explorer and click \u201cConnect\u201d in CoolTerm.    Follow the same steps as before to program the second radio. However, ATMY gets 2 and the ATDL gets 1. See the chart below.       Function  Command  Parameter      PAN ID  ATID  3001  (any address from 0 to FFFE will do)    MY Address  ATMY  2    Destination address high  ATDH  0  (indicates 1 16-bit address)    Destination address low  ATDL  1       Remember to type  ATWR  and press enter to save the settings.    Here's a sample of what a terminal looks like after taking these steps.", 
            "title": "XBee"
        }, 
        {
            "location": "/hardware/#sleepy-pi", 
            "text": "The transmission device connected to the camera trap requires  Sleepy Pi  for reducing power consumption. Sleepy Pi sits on top of the Raspberry Pi B+ as shown in the photo below.   The Sleepy Pi does not need a coin cell battery because we are not using Sleepy Pi's clock in the current version of the system.   You should put electric tape on the connectors of the Raspberry Pi to avoid short-circuiting Sleepy Pi. In general, Sleepy Pi is liable to short circuits, which can destroy the piece of hardware, so you should exert extra caution when working with the board.", 
            "title": "Sleepy Pi"
        }, 
        {
            "location": "/ct_system/", 
            "text": "About the photo transmission system\n\n\nThe main function of the photo-transmission system in the camera trap is to store camera pictures and allow the photo-transmission system in the drone to SSH into the Raspberry Pi to rsync the photos into the drone.\n\n\nDue to the limited power supply the power management arduino shield, Sleepy Pi, is used to turn Raspberry Pi off when not used.\n\n\nSetting Up Raspbian for Sleepy Pi\n\n\nThe summarized guide below follows the tutorial in the following link:\n\nhttp://spellfoundry.com/sleepy-pi/\n\n\nSetting up the Arduino IDE on Raspbian\n\n\nThe first step is to load the Arduino environment onto the Raspberry Pi. If you haven\u2019t already done so, it\u2019s a good idea to ensure that your Raspbian is up to date by opening up an LXTerminal window and executing the following:\n\n\n$ sudo apt-get update\n$ sudo apt-get dist-upgrade\n\n\n\n\nNote the dist-upgrade will ensure that you have the latest versions of RPi.GPIO which will be required later.\nNow install the Arduino IDE with:\n\n\n$ sudo apt-get install arduino\n\n\n\n\n(click Y to install any required dependencies)\n\n\nSetting up the Serial Pins\n\n\nThe Arduino processor on the Sleepy Pi can be programmed directly from the Raspberry Pi using the serial GPIO lines on the RPi and another GPIO line to reset the the Arduino to allow automatic code upload. These pins are:\n\n\n\n\nGPIO 14: TXD\n\n\nGPIO 15: RXD\n\n\nGPIO 22: Reset (see next section)\n\n\n\n\nBy default Raspbian has exclusive access to the serial pins to output status, debug data, and log in.\n\n\n1. Disable Serial login\n\n\nRaspbian allows you to login using the serial port. To use the Sleepy Pi we need to disable this. To do this, we need to edit /etc/inittab. In an LXTerminal window type:\n\n\n$ sudo leafpad /etc/inittab\n\n\n\n\nScroll down the bottom and you will find the lines:\n\n\n#Spawn a getty on Raspberry Pi Serial line\nT0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100\n\n\n\n\nYou need to comment the last line out (i.e. disabling it) with a \u201c#\u201d and save it, so that it results in:\n\n\n#Spawn a getty on Raspberry Pi Serial line\n#T0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100\n\n\n\n\n2. Disable Boot Info\n\n\nWhen Raspbian boots up it outputs boot information to the serial port and hence streams it to the Sleepy Pi (which is not particularly interested in it). To disable this we need to edit the\n\n/boot/cmdline.txt\n in LXTerminal:\n\n\n$ sudo leafpad /boot/cmdline.txt\n\n\n\n\nIt will look something like:\n\n\ndwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200\nconsole=tty1 root=/dev/mmcblk0p6 rootfstype=ext4 elevator=deadline\nrootwait\n\n\n\n\nDelete the \nconsole=ttyAMA0,115200 kgdboc=ttyAMA0,115200\n part so that you are left with:\n\n\ndwc_otg.lpm_enable=0 console=tty1 root=/dev/mmcblk0p6 rootfstype=ext4\nelevator=deadline rootwait\n\n\n\n\nThis is the file I use: (Should be in the download folder)\n\nLink to the full file\n\n\n3. Link the Serial port to the Arduino IDE\n\n\nThe Arduino IDE wants to use the /dev/ttyS0 serial port, but we need yo use the /dev/ttyAMA0 which is linked to the GPIO. In order to do this we need to create a permanent link that maps AMA0 to S0. To this we need to create a small file. We can do this in LXTerminal by the following sequence:\n\n\n$ sudo leafpad\n\n\n\n\nIn the new file that it creates type the following:\n\n\nKERNEL==\nttyAMA0\n, SYMLINK+=\nttyS0\n,GROUP=\ndialout\n,MODE:=0666\nKERNEL==\nttyACM0\n, SYMLINK+=\nttyS1\n,GROUP=\ndialout\n,MODE:=0666\n\n\n\n\nSave this file as a new file called \n80-sleepypi.rules\n to: \n/etc/udev/rules.d/\n\n\nThis is the one I use: (Should be in the download folder)\n\nLink to the full file\n\n\nSetting up the Reset (DTR) pin\n\n\nThe Sleepy Pi Arduino processor reset line in connected to GPIO 22. To automatically upload code from the Arduino IDE we need to pulse this line low to reset the Arduino and enter bootload mode.\n\n\nOn a normal Arduino system connected to a computer via a USB / serial cable the reset line is connected to the DTR line. To replicate this behavior on the Raspberry Pi we need to hack the AVRDude programming software. Dean Mao has detailed a great hack for this. He\u2019s produced a modified version of Avrdude (avrdude-autoreset) and written a piece of python code (autoreset) that runs in the background and pulses the GPIO line when required.\n\n\nUse the following from the command lines to download and unzip :\n\n\nwget https://github.com/SpellFoundry/avrdude-rpi/archive/master.zip\nsudo unzip master.zip\n\n\n\n\nNext, copy the files to the appropriate places from a LXTerminal window using the following commands:\n\n\n$ cd ./avrdude-rpi-master/\n$ sudo cp autoreset /usr/bin\n$ sudo cp avrdude-autoreset /usr/bin\n$ sudo mv /usr/bin/avrdude /usr/bin/avrdude-original\n\n\n\n\nThis renames your original avrdude, so that you have a backup and can replace it with the new one.\n\n\n$ sudo ln -s /usr/bin/avrdude-autoreset /usr/bin/avrdude\n\n\n\n\nLink the new avrdude-autoreset to avrdude so that when something calls for avrdude, the new version runs instead.\n\n\nAdding the Sleepy Pi to the Arduino environment\n\n\nTo enable the Sleepy Pi to be selected from the IDE you need to add a folder and file to your sketchbook. If it is a fresh install and you haven\u2019t yet run the Arduino environment you\u2019ll need to create a sketchbook folder (skip this step if it already exists).\n\n\nIn LXTerminal type:\n\n\n$ mkdir /home/pi/sketchbook\n$ mkdir /home/pi/sketchbook/hardware\n$ mkdir /home/pi/sketchbook/hardware/Sleepy_pi\n\n\n\n\nto create folders \u201chardware\u201d and \u201csleepy pi\u201d in your Arduino sketchbook.\nDownload and copy the boards.txt file to the Sleepy Pi folder.\n\nDownload the boards.txt file\n\n\nThis file should look like this:\n\n\nsleepypi.name=Sleepy Pi\nsleepypi.upload.protocol=arduino\nsleepypi.upload.maximum_size=30720\nsleepypi.upload.speed=57600\nsleepypi.bootloader.low_fuses=0xFF\nsleepypi.bootloader.high_fuses=0xDA\nsleepypi.bootloader.extended_fuses=0x05\nsleepypi.bootloader.path=arduino:atmega\nsleepypi.bootloader.file=ATmegaBOOT_168_atmega328_pro_8MHz.hex\nsleepypi.bootloader.unlock_bits=0x3F\nsleepypi.bootloader.lock_bits=0x0F\nsleepypi.build.mcu=atmega328p\nsleepypi.build.f_cpu=8000000L\nsleepypi.build.core=arduino:arduino\nsleepypi.build.variant=arduino:standard\n\n\n\n\nAnd finally reboot your Raspberry Pi to complete and load all our changes. You can use:\n\n\n$ sudo reboot\n\n\n\n\nGetting the Sleepy Pi to Shutdown the Raspberry Pi\n\n\nThe Sleepy Pi has the ability to co-ordinate a shutdown of the Raspberry Pi via two GPIO handshake lines:\n\n\n\n\nGPIO 24: Command the RPi to shutdown\n\n\nGPIO 25: Raspberry Pi is running\n\n\n\n\nSoftware must be running on both the Raspberry Pi and also the Sleepy Pi that react to these signals. From the Sleepy Pi\u2019s perspective, the shutdown sequence is as follows:\n\n\n\n\nSet GPIO 24 high to signal that we are going to shutdown\n\n\nMonitor GPIO 25, wait for it to go low indicating that the Raspberry Pi software has stopped running\n\n\nCut the power to the Raspberry Pi\n\n\n\n\nFrom the Raspberry Pi\u2019s perspective, the shutdown sequence is as follows:\n\n\n\n\nSet GPIO 25 to indicate that we are running\n\n\nMonitor GPIO 24 for a command to shutdown\n\n\nWhen we receive a command to shutdown issue a \nsudo shutdown -h now\n command\n\n\n\n\nTo properly handshake, the Raspberry Pi must install a script that runs at boot and continues in the background setting and monitoring the handshake lines.\n\n\nCopy the following script to \n/home/pi/bin/button/\n\n\nLink to donwload the file\n\n\nIt is possible that the directory doesn't exist. Make it with:\n\n\n$ mkdir /home/pi/bin\n$ mkdir /home/pi/bin/button\n\n\n\n\nThe shutdowncheck.py script looks like this:\n\n\n#!/usr/bin/python\n\nimport RPi.GPIO as GPIO\nimport os, time\n\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(24, GPIO.IN)\nGPIO.setup(25, GPIO.OUT)\nGPIO.output(25, GPIO.HIGH)\nprint (\n[Info] Telling Sleepy Pi we are running pin 25\n)\n\nwhile True:\n   if (GPIO.input(24)):\n      print (\nSleepy Pi requesting shutdown on pin 24\n)\n      os.system(\nsudo shutdown -h now\n)\n      break\n   time.sleep(0.5)\n\n\n\n\nTo run this script at startup, we must edit the \n/etc/rc.local\n\n\nIn LXTerminal:\n\n\n$ sudo leafpad /etc/rc.local\n\n\n\n\nand insert the following line just before the final exit 0 and save changes:\n\n\npython /home/pi/bin/button/shutdowncheck.py \n\n\n\n\n\nDO NOT forget the \u201c\n\u201d which allows the script to run in the background!\n(This script  is based on \nthis\n one)\n\n\nNOTE: On a fresh PI install you will need to set the permissions on /etc/rc/local so that it can execute at startup. To do this execute the following command from a terminal window:\n\n\nsudo chmod u+x /etc/rc.local\n\n\n\n\nInstalling Sleepy Pi and related libraries.\n\n\nMove the libraries from the \ndownload\n and put them in your \n/home/pi/sketchbook\n folder in the Raspberry Pi.\n\n\nMake sure that the Sketchbook location in \nFile \n Preferences\n is set to \n/home/pi/sketchbook\n\n\nMounting Camera Trap on Startup\n\n\nIMPORTANT: \nThis link\n explains the entirety of the following procedure.\n\n\nSolving the problem with mounting SD card\n\n\nTo be able to access the SD card on the camera trap form the Raspberry Pi special steps are required. If you don\u2019t start GUI, the SD card does not get mounted automatically and it does not appear in the directories\n\n\nTo solve the problem:\n\n\n\n\nconnect the usb device - sd card or hdd\n\n\nuse command \nsudo fdisk -l\n to list the available storage drives\n\n\ncamera trap SD card should be under the path \n/dev/sda1\n\n\nif you accessed the camera trap from GUI before, the SD card should already have a folder created for it in \n/media\n probably a folder name with number in it such as \n/media/6639-3235\n\n\nto create folder for the storage device \nsudo mkdir /media/usbhdd\n\n\npermission problem may occur during transfer - you must make user pi the owner of the folder to avoid these issues: \nsudo chown pi:pi /media/usbhdd\n\n\nfinally to mount the disk: \nsudo mount -t vfat -o uid=pi,gid=pi /dev/sda1 /media/usbhdd\n\n\nfinally unmount: \nsudo umount /media/usbhdd\n\n\n\n\nMount automatically on startup:\n\n\n\n\nedit the file system table: \nsudo nano /etc/fstab\n. You need to use sudo because the fstab file is owned by root.\n\n\nYou should see something like this:\n\n\n\n\nproc            /proc           proc    defaults          0       0\n/dev/mmcblk0p1  /boot           vfat    defaults          0       2\n/dev/mmcblk0p2  /               ext4    defaults,noatime  0       1\n\n\n\n\n\n\nAdd the following line, and save the file.\n\n\n\n\n/dev/sda1       /media/usbhdd   vfat    uid=pi,gid=pi     0       0\n\n\n\n\n\n\nReboot your Pi and you should be able to access your USB drive via \n/media/usbhdd\n.\n\n\n\n\nUploading Arduino Parser to SleepyPi\n\n\nArduino Parser is our name for the software that runs on the Sleepy Pi. Download the Arduino Parser \nfrom this link\n and upload it to SleepyPi. This can be done either through Raspberry Pi or through any computer.\n\n\nThe Arduino IDE can be found on the Main GUI menu in the Electronics section.\n\n\n\n\nOnce loaded the Sleepy Pi should be selected as a target from the Tools menu.\n\n\n\n\nTo test that you can program the Arduino correctly the \u201cBlink\u201d sketch is always a favourite. It can be found from the \nFile \n Examples \n 01.Basics \n Blink menu\n.\n\n\n\n\nPress the \u201cUpload\u201d button and the sketch will be compiled and uploaded. You should see a message from the \u201cautoreset\u201d displayed in the bottom status area.\n\n\n\n\nIf the sketch is successfully loaded, then the amber LED will begin flashing.", 
            "title": "Camera trap part of data mule"
        }, 
        {
            "location": "/ct_system/#about-the-photo-transmission-system", 
            "text": "The main function of the photo-transmission system in the camera trap is to store camera pictures and allow the photo-transmission system in the drone to SSH into the Raspberry Pi to rsync the photos into the drone.  Due to the limited power supply the power management arduino shield, Sleepy Pi, is used to turn Raspberry Pi off when not used.", 
            "title": "About the photo transmission system"
        }, 
        {
            "location": "/ct_system/#setting-up-raspbian-for-sleepy-pi", 
            "text": "The summarized guide below follows the tutorial in the following link: http://spellfoundry.com/sleepy-pi/  Setting up the Arduino IDE on Raspbian  The first step is to load the Arduino environment onto the Raspberry Pi. If you haven\u2019t already done so, it\u2019s a good idea to ensure that your Raspbian is up to date by opening up an LXTerminal window and executing the following:  $ sudo apt-get update\n$ sudo apt-get dist-upgrade  Note the dist-upgrade will ensure that you have the latest versions of RPi.GPIO which will be required later.\nNow install the Arduino IDE with:  $ sudo apt-get install arduino  (click Y to install any required dependencies)  Setting up the Serial Pins  The Arduino processor on the Sleepy Pi can be programmed directly from the Raspberry Pi using the serial GPIO lines on the RPi and another GPIO line to reset the the Arduino to allow automatic code upload. These pins are:   GPIO 14: TXD  GPIO 15: RXD  GPIO 22: Reset (see next section)   By default Raspbian has exclusive access to the serial pins to output status, debug data, and log in.  1. Disable Serial login  Raspbian allows you to login using the serial port. To use the Sleepy Pi we need to disable this. To do this, we need to edit /etc/inittab. In an LXTerminal window type:  $ sudo leafpad /etc/inittab  Scroll down the bottom and you will find the lines:  #Spawn a getty on Raspberry Pi Serial line\nT0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100  You need to comment the last line out (i.e. disabling it) with a \u201c#\u201d and save it, so that it results in:  #Spawn a getty on Raspberry Pi Serial line\n#T0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100  2. Disable Boot Info  When Raspbian boots up it outputs boot information to the serial port and hence streams it to the Sleepy Pi (which is not particularly interested in it). To disable this we need to edit the /boot/cmdline.txt  in LXTerminal:  $ sudo leafpad /boot/cmdline.txt  It will look something like:  dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200\nconsole=tty1 root=/dev/mmcblk0p6 rootfstype=ext4 elevator=deadline\nrootwait  Delete the  console=ttyAMA0,115200 kgdboc=ttyAMA0,115200  part so that you are left with:  dwc_otg.lpm_enable=0 console=tty1 root=/dev/mmcblk0p6 rootfstype=ext4\nelevator=deadline rootwait  This is the file I use: (Should be in the download folder) Link to the full file  3. Link the Serial port to the Arduino IDE  The Arduino IDE wants to use the /dev/ttyS0 serial port, but we need yo use the /dev/ttyAMA0 which is linked to the GPIO. In order to do this we need to create a permanent link that maps AMA0 to S0. To this we need to create a small file. We can do this in LXTerminal by the following sequence:  $ sudo leafpad  In the new file that it creates type the following:  KERNEL== ttyAMA0 , SYMLINK+= ttyS0 ,GROUP= dialout ,MODE:=0666\nKERNEL== ttyACM0 , SYMLINK+= ttyS1 ,GROUP= dialout ,MODE:=0666  Save this file as a new file called  80-sleepypi.rules  to:  /etc/udev/rules.d/  This is the one I use: (Should be in the download folder) Link to the full file  Setting up the Reset (DTR) pin  The Sleepy Pi Arduino processor reset line in connected to GPIO 22. To automatically upload code from the Arduino IDE we need to pulse this line low to reset the Arduino and enter bootload mode.  On a normal Arduino system connected to a computer via a USB / serial cable the reset line is connected to the DTR line. To replicate this behavior on the Raspberry Pi we need to hack the AVRDude programming software. Dean Mao has detailed a great hack for this. He\u2019s produced a modified version of Avrdude (avrdude-autoreset) and written a piece of python code (autoreset) that runs in the background and pulses the GPIO line when required.  Use the following from the command lines to download and unzip :  wget https://github.com/SpellFoundry/avrdude-rpi/archive/master.zip\nsudo unzip master.zip  Next, copy the files to the appropriate places from a LXTerminal window using the following commands:  $ cd ./avrdude-rpi-master/\n$ sudo cp autoreset /usr/bin\n$ sudo cp avrdude-autoreset /usr/bin\n$ sudo mv /usr/bin/avrdude /usr/bin/avrdude-original  This renames your original avrdude, so that you have a backup and can replace it with the new one.  $ sudo ln -s /usr/bin/avrdude-autoreset /usr/bin/avrdude  Link the new avrdude-autoreset to avrdude so that when something calls for avrdude, the new version runs instead.  Adding the Sleepy Pi to the Arduino environment  To enable the Sleepy Pi to be selected from the IDE you need to add a folder and file to your sketchbook. If it is a fresh install and you haven\u2019t yet run the Arduino environment you\u2019ll need to create a sketchbook folder (skip this step if it already exists).  In LXTerminal type:  $ mkdir /home/pi/sketchbook\n$ mkdir /home/pi/sketchbook/hardware\n$ mkdir /home/pi/sketchbook/hardware/Sleepy_pi  to create folders \u201chardware\u201d and \u201csleepy pi\u201d in your Arduino sketchbook.\nDownload and copy the boards.txt file to the Sleepy Pi folder. Download the boards.txt file  This file should look like this:  sleepypi.name=Sleepy Pi\nsleepypi.upload.protocol=arduino\nsleepypi.upload.maximum_size=30720\nsleepypi.upload.speed=57600\nsleepypi.bootloader.low_fuses=0xFF\nsleepypi.bootloader.high_fuses=0xDA\nsleepypi.bootloader.extended_fuses=0x05\nsleepypi.bootloader.path=arduino:atmega\nsleepypi.bootloader.file=ATmegaBOOT_168_atmega328_pro_8MHz.hex\nsleepypi.bootloader.unlock_bits=0x3F\nsleepypi.bootloader.lock_bits=0x0F\nsleepypi.build.mcu=atmega328p\nsleepypi.build.f_cpu=8000000L\nsleepypi.build.core=arduino:arduino\nsleepypi.build.variant=arduino:standard  And finally reboot your Raspberry Pi to complete and load all our changes. You can use:  $ sudo reboot  Getting the Sleepy Pi to Shutdown the Raspberry Pi  The Sleepy Pi has the ability to co-ordinate a shutdown of the Raspberry Pi via two GPIO handshake lines:   GPIO 24: Command the RPi to shutdown  GPIO 25: Raspberry Pi is running   Software must be running on both the Raspberry Pi and also the Sleepy Pi that react to these signals. From the Sleepy Pi\u2019s perspective, the shutdown sequence is as follows:   Set GPIO 24 high to signal that we are going to shutdown  Monitor GPIO 25, wait for it to go low indicating that the Raspberry Pi software has stopped running  Cut the power to the Raspberry Pi   From the Raspberry Pi\u2019s perspective, the shutdown sequence is as follows:   Set GPIO 25 to indicate that we are running  Monitor GPIO 24 for a command to shutdown  When we receive a command to shutdown issue a  sudo shutdown -h now  command   To properly handshake, the Raspberry Pi must install a script that runs at boot and continues in the background setting and monitoring the handshake lines.  Copy the following script to  /home/pi/bin/button/  Link to donwload the file  It is possible that the directory doesn't exist. Make it with:  $ mkdir /home/pi/bin\n$ mkdir /home/pi/bin/button  The shutdowncheck.py script looks like this:  #!/usr/bin/python\n\nimport RPi.GPIO as GPIO\nimport os, time\n\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(24, GPIO.IN)\nGPIO.setup(25, GPIO.OUT)\nGPIO.output(25, GPIO.HIGH)\nprint ( [Info] Telling Sleepy Pi we are running pin 25 )\n\nwhile True:\n   if (GPIO.input(24)):\n      print ( Sleepy Pi requesting shutdown on pin 24 )\n      os.system( sudo shutdown -h now )\n      break\n   time.sleep(0.5)  To run this script at startup, we must edit the  /etc/rc.local  In LXTerminal:  $ sudo leafpad /etc/rc.local  and insert the following line just before the final exit 0 and save changes:  python /home/pi/bin/button/shutdowncheck.py    DO NOT forget the \u201c \u201d which allows the script to run in the background!\n(This script  is based on  this  one)  NOTE: On a fresh PI install you will need to set the permissions on /etc/rc/local so that it can execute at startup. To do this execute the following command from a terminal window:  sudo chmod u+x /etc/rc.local  Installing Sleepy Pi and related libraries.  Move the libraries from the  download  and put them in your  /home/pi/sketchbook  folder in the Raspberry Pi.  Make sure that the Sketchbook location in  File   Preferences  is set to  /home/pi/sketchbook", 
            "title": "Setting Up Raspbian for Sleepy Pi"
        }, 
        {
            "location": "/ct_system/#mounting-camera-trap-on-startup", 
            "text": "IMPORTANT:  This link  explains the entirety of the following procedure.  Solving the problem with mounting SD card  To be able to access the SD card on the camera trap form the Raspberry Pi special steps are required. If you don\u2019t start GUI, the SD card does not get mounted automatically and it does not appear in the directories  To solve the problem:   connect the usb device - sd card or hdd  use command  sudo fdisk -l  to list the available storage drives  camera trap SD card should be under the path  /dev/sda1  if you accessed the camera trap from GUI before, the SD card should already have a folder created for it in  /media  probably a folder name with number in it such as  /media/6639-3235  to create folder for the storage device  sudo mkdir /media/usbhdd  permission problem may occur during transfer - you must make user pi the owner of the folder to avoid these issues:  sudo chown pi:pi /media/usbhdd  finally to mount the disk:  sudo mount -t vfat -o uid=pi,gid=pi /dev/sda1 /media/usbhdd  finally unmount:  sudo umount /media/usbhdd   Mount automatically on startup:   edit the file system table:  sudo nano /etc/fstab . You need to use sudo because the fstab file is owned by root.  You should see something like this:   proc            /proc           proc    defaults          0       0\n/dev/mmcblk0p1  /boot           vfat    defaults          0       2\n/dev/mmcblk0p2  /               ext4    defaults,noatime  0       1   Add the following line, and save the file.   /dev/sda1       /media/usbhdd   vfat    uid=pi,gid=pi     0       0   Reboot your Pi and you should be able to access your USB drive via  /media/usbhdd .", 
            "title": "Mounting Camera Trap on Startup"
        }, 
        {
            "location": "/ct_system/#uploading-arduino-parser-to-sleepypi", 
            "text": "Arduino Parser is our name for the software that runs on the Sleepy Pi. Download the Arduino Parser  from this link  and upload it to SleepyPi. This can be done either through Raspberry Pi or through any computer.  The Arduino IDE can be found on the Main GUI menu in the Electronics section.   Once loaded the Sleepy Pi should be selected as a target from the Tools menu.   To test that you can program the Arduino correctly the \u201cBlink\u201d sketch is always a favourite. It can be found from the  File   Examples   01.Basics   Blink menu .   Press the \u201cUpload\u201d button and the sketch will be compiled and uploaded. You should see a message from the \u201cautoreset\u201d displayed in the bottom status area.   If the sketch is successfully loaded, then the amber LED will begin flashing.", 
            "title": "Uploading Arduino Parser to SleepyPi"
        }, 
        {
            "location": "/drone_system/", 
            "text": "Drone Photo-Transmission System\n\n\nThe main purpose of this system is to behave as a wireless hotspot and SSH\ninto the photo-transmission system in the camera trap and retrieve the photos using RSYNC.\n\n\nSetting Up Passwordless Wifi Hotspot\n\n\nThis section of the guide follows mostly through \nthis tutorial by adafruit\n.\n\n\nFirst of all, install the software onto the Pi that will act as the 'hostap' (host access point)\n\n\nTo do so \nyou need internet access\n so make sure you either have ethernet of wifi connected.\n\n\nsudo apt-get update\n\n\nsudo apt-get install hostapd isc-dhcp-server\n\n\n(You may need to \nsudo apt-get update\n if the Pi can't seem to get to the apt-get repositories)\n\n\n\n(text above shows udhcpd but that doesnt work as well as isc-dhcp-server, still, the output should look similar)\n\n\nConfigure Access Point\n\n\nNow we can configure the access point details. We will set up a password-protected network so only people with the password can connect.\n\n\nCreate a new file by running\n\n\nsudo nano /etc/hostapd/hostapd.conf\n\n\nPaste the following in, you can change the text after ssid= to another name, that will be the network broadcast name. The password can be changed with the text after \nwpa_passphrase=\n. Make sure to type \nL\n in rt\nl\n871xdrv rather than a \n1\n.\n\n\ninterface=wlan0\ndriver=rtl871xdrv\nssid=WadiDrone\nhw_mode=g\nchannel=6\nmacaddr_acl=0\nauth_algs=1\nignore_broadcast_ssid=0\n\n\n\n\nIf you are not using the Adafruit wifi adapters, you may have to change the \ndriver=rtl871xdrv\n to say \ndriver=nl80211\n or something, we don't have tutorial support for that tho, YMMV!\n\n\n\nSave as usual. Make sure each line has no extra spaces or tabs at the end or beginning - this file is pretty picky!\n\n\nNow we will tell the Pi where to find this configuration file. Run \nsudo nano /etc/default/hostapd\n\n\nFind the line \n#DAEMON_CONF=\"\"\n and edit it so it says \nDAEMON_CONF=\"/etc/hostapd/hostapd.conf\"\n\nDon't forget to remove the \n#\n in front to activate it!\n\n\nThen save the file\n\n\n\n\nUpdate hostapd\n\n\nBefore we can run the access point software, we have to update it to a version that supports the WiFi adapter.\nFirst get the new version by typing in\n\n\nwget http://adafruit-download.s3.amazonaws.com/adafruit_hostapd_14128.zip\n\n\nthen\n\n\nunzip adafruit_hostapd_14128.zip\n\n\nto uncompress it. Move the old version out of the way with\n\n\nsudo mv /usr/sbin/hostapd /usr/sbin/hostapd.ORIG\n\n\nAnd move the new version back with\n\n\nsudo mv hostapd /usr/sbin\n\n\nset it up so its valid to run with\n\n\nsudo chmod 755 /usr/sbin/hostapd\n\n\n\n\nSetup DHCP Server\n\n\nNext we will edit \n/etc/dhcp/dhcpd.conf\n, a file that sets up our DHCP server - this allows wifi connections to automatically get IP addresses, DNS, etc.\n\n\nRun this command to edit the file\n\n\nsudo nano /etc/dhcp/dhcpd.conf\n\n\nFind the lines that say\n\n\noption domain-name \nexample.org\n;\noption domain-name-servers ns1.example.org, ns2.example.org;\n\n\n\n\nand change them to add a \n#\n in the beginning so they say\n\n\n#option domain-name \nexample.org\n;\n#option domain-name-servers ns1.example.org, ns2.example.org;\n\n\n\n\nFind the lines that say\n\n\n# If this DHCP server is the official DHCP server for the local\n# network, the authoritative directive should be uncommented.\n#authoritative;\n\n\n\n\nand remove the \n#\n so it says\n\n\n# If this DHCP server is the official DHCP server for the local\n# network, the authoritative directive should be uncommented.\nauthoritative;\n\n\n\n\n\n\nThen scroll down to the bottom and add the following lines.\n\n\nsubnet 192.168.10.0 netmask 255.255.255.0 {\n        range 192.168.10.10 192.168.10.20;\n        option broadcast-address 192.168.10.255;\n        option routers 192.168.10.1;\n        default-lease-time 600;\n        max-lease-time 7200;\n        option domain-name \nlocal\n;\n        option domain-name-servers 8.8.8.8, 8.8.4.4;\n}\n\n\n\n\nNote, that the screenshot below only illustrates the code, but you should type the code above.\n\n\n\n\nSave the file by typing in \nControl-X\n then \nY\n then \nreturn\n\n\nRun\n\n\nsudo nano /etc/default/isc-dhcp-server\n\n\nand scroll down to \nINTERFACES=\"\"\n and update it to say \nINTERFACES=\"wlan0\"\n\n\n\n\nclose and save the file\n\n\nSetup Wlan0 For Static IP\n\n\nIf you happen to have wlan0 active because you set it up, run \nsudo ifdown wlan0\n\nThere's no harm in running it if you're not sure\n\n\n\n\nNext we will set up the \nwlan0\n connection to be static and incoming.\nrun \nsudo nano /etc/network/interfaces\n to edit the file\n\n\nFind the line \nauto wlan0\n and add a \n#\n in front of the line,\nand in front of every line afterwards. If you don't have that line,\njust make sure it looks like the screenshot below in the end!\nBasically just remove any old wlan0 configuration settings, we'll\nbe changing them up\n\n\nDepending on your existing setup/distribution there might be\nmore or less text and it may vary a little bit\nAdd the lines\n\n\niface wlan0 inet static\naddress 192.168.10.1\nnetmask 255.255.255.0\n\n\n\n\nAfter allow \nhotplug wlan0\n - see below for an example of what it should\nlook like. (ignore our hyphen in allow-hotplug tho, its a typo!) Any other\nlines afterwards should have a \n#\n in front to disable them.\n\n\n\n\nSave the file \n(Control-X Y return)\n\nAssign a static IP address to the wifi adapter by running\n\n\nsudo ifconfig wlan0 192.168.10.1\n\n\n\n\nFirst test!\nFinally we can test the access point host! Run\n\n\nsudo /usr/sbin/hostapd /etc/hostapd/hostapd.conf\n\n\nTo manually run \nhostapd\n with our configuration file.\nYou should see it set up and use \nwlan0\n then you can check with another\nwifi computer that you see your SSID show up. If so, you have successfully\n set up the access point.\n\n\n\n\n\n\nYou can try connecting and disconnecting from the WadiDrone with\nthe password you set before, debug text will display on the Pi console\n but you won't be able to connect through to the Ethernet connection yet.\nCancel the test by typing \nControl-C\n in the Pi console to get\nback to the Pi command line.\n\n\nFinishing up!\n\n\nOK now that we know it works, time to set it up as a 'daemon' - a program that will start when the Pi boots.\nRun the following commands\n\n\nsudo service hostapd start\nsudo service isc-dhcp-server start\n\n\n\n\nyou can always check the status of the host AP server and the DHCP server with\n\n\nsudo service hostapd status\nsudo service isc-dhcp-server status\n\n\n\n\nTo start the daemon services. Verify that they both start successfully\n(no 'failure' or 'errors')\n\n\nThen to make it so it runs every time on boot\n\n\nsudo update-rc.d hostapd enable\nsudo update-rc.d isc-dhcp-server enable\n\n\n\n\n\n\nLeasing static IP address to camera-trap photo transmission system\n\n\nIn this part of the tutorial, you will have to work with both the camera trap and the drone system. For each camera trap that you want to serve with the drone, you will have to alter the config file.\n\n\nIn the camera trap:\n\n\nIn the raspberry at the camera trap modify the\n\n\n/etc/network/interfaces\n\n\nso it looks like the following\n\n\nauto lo\niface lo inet loopback\niface eth0 inet dhcp\nauto wlan0\nallow-hotplug wlan0\niface wlan0 inet dhcp\nwpa-conf /etc/wpa_supplicant/wpa_supplicant.conf\niface default inet dhcp\n\n\n\n\ncomment out the rest of the code\n\n\nMake\n\n\n/etc/wpa_supplicant/wpa_supplicant.conf\n\n\nlook like the following\n\n\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\nnetwork={\n        ssid=\nWadiDrone\n\n        key_mgmt=NONE\n        auth_alg=OPEN\n        id_str=\nWadiDrone\n\n}\n\n\n\n\nIn the drone:\n\n\nFor each camera that you want to add to the system, you will have to add a static address to the record of the drone. Here we revisit the dhcpd.conf file from the previous part of the tutorial. This tutorial assumed you already setup the Wi-Fi hotspot using previous tutorial. Type the following command in the terminal:\n\n\nsudo nano /etc/dhcp/dhcpd.conf\n\n\nAdd the following lines at the end of the file. The MAC address is individual to each Raspberry Pi and it can be found by typing \nifconfig\n into the Terminal of the camera trap Raspberry Pi. The IP address also has to be unique, but you can assign it arbitrarily as long as it does not conflict with any of the other IP addresses. For setting the IP address, you must change the number after the last dot.\n\n\nhost camera1 { #add the name of the camera\n        hardware ethernet 80:1f:02:ef:e6:f2; #add the MAC address of the raspberry pi of camera\n        fixed-address 192.168.10.21; #the static ip you want to assign to the trap\n}\n\n\n\n\nImportant:\n If the static leasing of the IP address does not work, restart the drone first and then restart the camera trap.\n\n\nEstablishing SSH connection with Camera Trap without Password\n\n\nBecause photos are transmitted using \nRSync\n, which uses SSH secure connection for transmission, you need to add drones's public key into the camera trap transmission system. Our tutorial draws liberally on material from this  \ntutorial\n.\n\n\nIt is possible to configure your Pi to allow your computer to access it without\nproviding a password each time you try to connect. To do this you need to\ngenerate an SSH key.\n\n\nPotential problem (you may skip)\n\n\nDepending on how your computer is configured and whether you tried to SSH into the Raspberry Pi before, your will see the following message\n\n\n\n\nIn order to remove the message you will need to call the following code in your terminal to remove the offending SSH key from your records. The IP address refers to the address of the drone hotspot.\n\n\nssh-keygen -R 192.168.10.1\n\n\n\n\nCheck for the existing keys\n\n\nFirst, check whether there are already keys on the drone Raspberry Pi:\n\n\nls ~/.ssh\n\n\nIf you see files named \nid_rsa.pub\n or \nid_dsa.pub\n you have keys set up\nalready, so you can skip the generating keys step (or delete these files\nwith \nrm id*\n and make new keys).\n\n\nGenerate new SSH key for the drone\n\n\nTo generate new SSH keys enter the following command (Choose a sensible\nhostname such as \n@\n where we have used \ndrone@pi\n):\n\n\nssh-keygen -t rsa -C drone@pi\n\n\nUpon entering this command, you'll be asked where to save the key.\nWe suggest you save it in the default location (\n/home/pi/.ssh/id_rsa\n)\nby just hitting Enter.\n\n\nYou'll also be asked to enter a passphrase. This is extra security which\nwill make the key unusable without your passphrase, so if someone else copied\nyour key, they could not impersonate you to gain access. If you choose to use a\n passphrase, type it here and press Enter, then type it again when prompted. Le\n ave empty for no passphrase.\n\n\nNow you should see the files \nid_rsa\n and \nid_rsa.pub\n in your \n.sshdirectory\n\n in your home folder:\n\n\nls ~/.ssh\nauthorized_keys  id_rsa  id_rsa.pub  known_hosts\n\n\n\n\nThe \nid_rsa\n file is your private key. Keep this on your computer.\nThe \nid_rsa.pub\n file is your public key. This is what you put on\nmachines you want to connect to. When the machine you try to connect to\n matches up your public and private key, it will allow you to connect.\n\n\nTake a look at your public key to see what it looks like:\n\n\ncat ~/.ssh/id_rsa.pub\n\n\nIt should be in the form:\n\n\nssh-rsa \n drone@pi\n\n\nCopy your public key into camera trap\n\n\nTo copy your public key to CAMERA TRAP, use the following command to append\nthe public key to your authorized_keys file on the CAMERA TRAP, sending it\nover SSH:\n\n\ncat ~/.ssh/id_rsa.pub | ssh \nUSERNAME\n@\nIP-ADDRESS\n 'cat \n .ssh/authorized_keys'\n\n\n\n\nNote that this time you will have to authenticate with your password.\n\n\nNow try ssh \n@\n and you should connect without a\npassword prompt.\nIf you see a message \n\"Agent admitted failure to sign using the key.\"\n\n then add your RSA or DSA identities to the authentication agent, ssh-agent the execute the following command:\n\n\nssh-add\n\n\nIf this did not work, delete your keys with \nrm ~/.ssh/id*\n and follow the\n instructions again.\n\n\nYou can also send files over SSH using the scp command (secure copy). See\nthe SCP guide for more information.\n\n\nMaking Raspberry Pi execute a script on startup\n\n\nA crucial part of the system is a Python script that runs on the startup and executes in a loop. When a camera trap transmission station becomes in range, the Python script downloads photos from the camera trap. In order to run the script, you must follow these steps:\n\n\nBased on this \ntutorial\n\n\nAuto Login\n\n\nHow to automatically login to Raspberry Pi console as pi user.\n\n\nStep 1: Open a terminal session and edit inittab file.\n\n\nsudo nano /etc/inittab\n\n\nStep 2: Disable the getty program.\n\n\nNavigate to the following line in inittab\n\n\n1:2345:respawn:/sbin/getty 38400 tty1\n\n\nAnd add a \n#\n at the beginning of the line to comment it out\n\n\n#1:2345:respawn:/sbin/getty 38400 tty1\n\n\nStep 3: Add login program to inittab.\n\n\nAdd the following line just below the commented line\n\n\n1:2345:respawn:/bin/login -f pi tty1 \n/dev/tty1 \n/dev/tty1 2\n1\n\n\nThis will run the login program with pi user and without any authentication\n\n\nStep 4: Save and Exit.\n\n\nPress \nCtrl+X\n to exit nano editor followed by \nY\n to save the\nfile and then press \nEnter\n to confirm the filename.\n\n\nReboot the pi and it will boot straight on to the shell prompt\n\npi@raspberrypi\n without prompting you to enter username or password.\nBut this isn't enough; you need your Pi to automatically run some\ncommand or a script. which is explained in the next section.\n\n\nRun a Python Script after login\n\n\nIt is desirable to run the Python script automatically after login, so that drone starts looking for camera traps any time the system is on. The name of the file that runs in the Raspberrry Pi is currently \"\nDroneControlClassesCompetition.py\n.\" Download this file onto the desktop of the drone Raspberry Pi, where you will be able to edit it in the future.\n\n\nStep 1: Open a terminal session and edit the file /etc/profile\n\n\nsudo nano /etc/profile\n\n\nStep 2: Add the following line to the end of the file\n\n\npython /home/pi/Desktop/DroneControlClassesCompetition.py \n\n\nreplace the script name and path with correct name and path of your start-up script.\n\n\nStep 3: Save and Exit\n\n\nPress \nCtrl+X\n to exit nano editor followed by \nY\n to save the file.", 
            "title": "UAS part of data mule"
        }, 
        {
            "location": "/drone_system/#drone-photo-transmission-system", 
            "text": "The main purpose of this system is to behave as a wireless hotspot and SSH\ninto the photo-transmission system in the camera trap and retrieve the photos using RSYNC.", 
            "title": "Drone Photo-Transmission System"
        }, 
        {
            "location": "/drone_system/#setting-up-passwordless-wifi-hotspot", 
            "text": "This section of the guide follows mostly through  this tutorial by adafruit .  First of all, install the software onto the Pi that will act as the 'hostap' (host access point)  To do so  you need internet access  so make sure you either have ethernet of wifi connected.  sudo apt-get update  sudo apt-get install hostapd isc-dhcp-server  (You may need to  sudo apt-get update  if the Pi can't seem to get to the apt-get repositories)  (text above shows udhcpd but that doesnt work as well as isc-dhcp-server, still, the output should look similar)", 
            "title": "Setting Up Passwordless Wifi Hotspot"
        }, 
        {
            "location": "/drone_system/#configure-access-point", 
            "text": "Now we can configure the access point details. We will set up a password-protected network so only people with the password can connect.  Create a new file by running  sudo nano /etc/hostapd/hostapd.conf  Paste the following in, you can change the text after ssid= to another name, that will be the network broadcast name. The password can be changed with the text after  wpa_passphrase= . Make sure to type  L  in rt l 871xdrv rather than a  1 .  interface=wlan0\ndriver=rtl871xdrv\nssid=WadiDrone\nhw_mode=g\nchannel=6\nmacaddr_acl=0\nauth_algs=1\nignore_broadcast_ssid=0  If you are not using the Adafruit wifi adapters, you may have to change the  driver=rtl871xdrv  to say  driver=nl80211  or something, we don't have tutorial support for that tho, YMMV!  \nSave as usual. Make sure each line has no extra spaces or tabs at the end or beginning - this file is pretty picky!  Now we will tell the Pi where to find this configuration file. Run  sudo nano /etc/default/hostapd  Find the line  #DAEMON_CONF=\"\"  and edit it so it says  DAEMON_CONF=\"/etc/hostapd/hostapd.conf\" \nDon't forget to remove the  #  in front to activate it!  Then save the file   Update hostapd  Before we can run the access point software, we have to update it to a version that supports the WiFi adapter.\nFirst get the new version by typing in  wget http://adafruit-download.s3.amazonaws.com/adafruit_hostapd_14128.zip  then  unzip adafruit_hostapd_14128.zip  to uncompress it. Move the old version out of the way with  sudo mv /usr/sbin/hostapd /usr/sbin/hostapd.ORIG  And move the new version back with  sudo mv hostapd /usr/sbin  set it up so its valid to run with  sudo chmod 755 /usr/sbin/hostapd   Setup DHCP Server  Next we will edit  /etc/dhcp/dhcpd.conf , a file that sets up our DHCP server - this allows wifi connections to automatically get IP addresses, DNS, etc.  Run this command to edit the file  sudo nano /etc/dhcp/dhcpd.conf  Find the lines that say  option domain-name  example.org ;\noption domain-name-servers ns1.example.org, ns2.example.org;  and change them to add a  #  in the beginning so they say  #option domain-name  example.org ;\n#option domain-name-servers ns1.example.org, ns2.example.org;  Find the lines that say  # If this DHCP server is the official DHCP server for the local\n# network, the authoritative directive should be uncommented.\n#authoritative;  and remove the  #  so it says  # If this DHCP server is the official DHCP server for the local\n# network, the authoritative directive should be uncommented.\nauthoritative;   Then scroll down to the bottom and add the following lines.  subnet 192.168.10.0 netmask 255.255.255.0 {\n        range 192.168.10.10 192.168.10.20;\n        option broadcast-address 192.168.10.255;\n        option routers 192.168.10.1;\n        default-lease-time 600;\n        max-lease-time 7200;\n        option domain-name  local ;\n        option domain-name-servers 8.8.8.8, 8.8.4.4;\n}  Note, that the screenshot below only illustrates the code, but you should type the code above.   Save the file by typing in  Control-X  then  Y  then  return  Run  sudo nano /etc/default/isc-dhcp-server  and scroll down to  INTERFACES=\"\"  and update it to say  INTERFACES=\"wlan0\"   close and save the file  Setup Wlan0 For Static IP  If you happen to have wlan0 active because you set it up, run  sudo ifdown wlan0 \nThere's no harm in running it if you're not sure   Next we will set up the  wlan0  connection to be static and incoming.\nrun  sudo nano /etc/network/interfaces  to edit the file  Find the line  auto wlan0  and add a  #  in front of the line,\nand in front of every line afterwards. If you don't have that line,\njust make sure it looks like the screenshot below in the end!\nBasically just remove any old wlan0 configuration settings, we'll\nbe changing them up  Depending on your existing setup/distribution there might be\nmore or less text and it may vary a little bit\nAdd the lines  iface wlan0 inet static\naddress 192.168.10.1\nnetmask 255.255.255.0  After allow  hotplug wlan0  - see below for an example of what it should\nlook like. (ignore our hyphen in allow-hotplug tho, its a typo!) Any other\nlines afterwards should have a  #  in front to disable them.   Save the file  (Control-X Y return) \nAssign a static IP address to the wifi adapter by running  sudo ifconfig wlan0 192.168.10.1   First test!\nFinally we can test the access point host! Run  sudo /usr/sbin/hostapd /etc/hostapd/hostapd.conf  To manually run  hostapd  with our configuration file.\nYou should see it set up and use  wlan0  then you can check with another\nwifi computer that you see your SSID show up. If so, you have successfully\n set up the access point.    You can try connecting and disconnecting from the WadiDrone with\nthe password you set before, debug text will display on the Pi console\n but you won't be able to connect through to the Ethernet connection yet.\nCancel the test by typing  Control-C  in the Pi console to get\nback to the Pi command line.  Finishing up!  OK now that we know it works, time to set it up as a 'daemon' - a program that will start when the Pi boots.\nRun the following commands  sudo service hostapd start\nsudo service isc-dhcp-server start  you can always check the status of the host AP server and the DHCP server with  sudo service hostapd status\nsudo service isc-dhcp-server status  To start the daemon services. Verify that they both start successfully\n(no 'failure' or 'errors')  Then to make it so it runs every time on boot  sudo update-rc.d hostapd enable\nsudo update-rc.d isc-dhcp-server enable", 
            "title": "Configure Access Point"
        }, 
        {
            "location": "/drone_system/#leasing-static-ip-address-to-camera-trap-photo-transmission-system", 
            "text": "In this part of the tutorial, you will have to work with both the camera trap and the drone system. For each camera trap that you want to serve with the drone, you will have to alter the config file.  In the camera trap:  In the raspberry at the camera trap modify the  /etc/network/interfaces  so it looks like the following  auto lo\niface lo inet loopback\niface eth0 inet dhcp\nauto wlan0\nallow-hotplug wlan0\niface wlan0 inet dhcp\nwpa-conf /etc/wpa_supplicant/wpa_supplicant.conf\niface default inet dhcp  comment out the rest of the code  Make  /etc/wpa_supplicant/wpa_supplicant.conf  look like the following  ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\nnetwork={\n        ssid= WadiDrone \n        key_mgmt=NONE\n        auth_alg=OPEN\n        id_str= WadiDrone \n}  In the drone:  For each camera that you want to add to the system, you will have to add a static address to the record of the drone. Here we revisit the dhcpd.conf file from the previous part of the tutorial. This tutorial assumed you already setup the Wi-Fi hotspot using previous tutorial. Type the following command in the terminal:  sudo nano /etc/dhcp/dhcpd.conf  Add the following lines at the end of the file. The MAC address is individual to each Raspberry Pi and it can be found by typing  ifconfig  into the Terminal of the camera trap Raspberry Pi. The IP address also has to be unique, but you can assign it arbitrarily as long as it does not conflict with any of the other IP addresses. For setting the IP address, you must change the number after the last dot.  host camera1 { #add the name of the camera\n        hardware ethernet 80:1f:02:ef:e6:f2; #add the MAC address of the raspberry pi of camera\n        fixed-address 192.168.10.21; #the static ip you want to assign to the trap\n}  Important:  If the static leasing of the IP address does not work, restart the drone first and then restart the camera trap.", 
            "title": "Leasing static IP address to camera-trap photo transmission system"
        }, 
        {
            "location": "/drone_system/#establishing-ssh-connection-with-camera-trap-without-password", 
            "text": "Because photos are transmitted using  RSync , which uses SSH secure connection for transmission, you need to add drones's public key into the camera trap transmission system. Our tutorial draws liberally on material from this   tutorial .  It is possible to configure your Pi to allow your computer to access it without\nproviding a password each time you try to connect. To do this you need to\ngenerate an SSH key.  Potential problem (you may skip)  Depending on how your computer is configured and whether you tried to SSH into the Raspberry Pi before, your will see the following message   In order to remove the message you will need to call the following code in your terminal to remove the offending SSH key from your records. The IP address refers to the address of the drone hotspot.  ssh-keygen -R 192.168.10.1  Check for the existing keys  First, check whether there are already keys on the drone Raspberry Pi:  ls ~/.ssh  If you see files named  id_rsa.pub  or  id_dsa.pub  you have keys set up\nalready, so you can skip the generating keys step (or delete these files\nwith  rm id*  and make new keys).  Generate new SSH key for the drone  To generate new SSH keys enter the following command (Choose a sensible\nhostname such as  @  where we have used  drone@pi ):  ssh-keygen -t rsa -C drone@pi  Upon entering this command, you'll be asked where to save the key.\nWe suggest you save it in the default location ( /home/pi/.ssh/id_rsa )\nby just hitting Enter.  You'll also be asked to enter a passphrase. This is extra security which\nwill make the key unusable without your passphrase, so if someone else copied\nyour key, they could not impersonate you to gain access. If you choose to use a\n passphrase, type it here and press Enter, then type it again when prompted. Le\n ave empty for no passphrase.  Now you should see the files  id_rsa  and  id_rsa.pub  in your  .sshdirectory \n in your home folder:  ls ~/.ssh\nauthorized_keys  id_rsa  id_rsa.pub  known_hosts  The  id_rsa  file is your private key. Keep this on your computer.\nThe  id_rsa.pub  file is your public key. This is what you put on\nmachines you want to connect to. When the machine you try to connect to\n matches up your public and private key, it will allow you to connect.  Take a look at your public key to see what it looks like:  cat ~/.ssh/id_rsa.pub  It should be in the form:  ssh-rsa   drone@pi  Copy your public key into camera trap  To copy your public key to CAMERA TRAP, use the following command to append\nthe public key to your authorized_keys file on the CAMERA TRAP, sending it\nover SSH:  cat ~/.ssh/id_rsa.pub | ssh  USERNAME @ IP-ADDRESS  'cat   .ssh/authorized_keys'  Note that this time you will have to authenticate with your password.  Now try ssh  @  and you should connect without a\npassword prompt.\nIf you see a message  \"Agent admitted failure to sign using the key.\" \n then add your RSA or DSA identities to the authentication agent, ssh-agent the execute the following command:  ssh-add  If this did not work, delete your keys with  rm ~/.ssh/id*  and follow the\n instructions again.  You can also send files over SSH using the scp command (secure copy). See\nthe SCP guide for more information.", 
            "title": "Establishing SSH connection with Camera Trap without Password"
        }, 
        {
            "location": "/drone_system/#making-raspberry-pi-execute-a-script-on-startup", 
            "text": "A crucial part of the system is a Python script that runs on the startup and executes in a loop. When a camera trap transmission station becomes in range, the Python script downloads photos from the camera trap. In order to run the script, you must follow these steps:  Based on this  tutorial  Auto Login  How to automatically login to Raspberry Pi console as pi user.  Step 1: Open a terminal session and edit inittab file.  sudo nano /etc/inittab  Step 2: Disable the getty program.  Navigate to the following line in inittab  1:2345:respawn:/sbin/getty 38400 tty1  And add a  #  at the beginning of the line to comment it out  #1:2345:respawn:/sbin/getty 38400 tty1  Step 3: Add login program to inittab.  Add the following line just below the commented line  1:2345:respawn:/bin/login -f pi tty1  /dev/tty1  /dev/tty1 2 1  This will run the login program with pi user and without any authentication  Step 4: Save and Exit.  Press  Ctrl+X  to exit nano editor followed by  Y  to save the\nfile and then press  Enter  to confirm the filename.  Reboot the pi and it will boot straight on to the shell prompt pi@raspberrypi  without prompting you to enter username or password.\nBut this isn't enough; you need your Pi to automatically run some\ncommand or a script. which is explained in the next section.", 
            "title": "Making Raspberry Pi execute a script on startup"
        }, 
        {
            "location": "/drone_system/#run-a-python-script-after-login", 
            "text": "It is desirable to run the Python script automatically after login, so that drone starts looking for camera traps any time the system is on. The name of the file that runs in the Raspberrry Pi is currently \" DroneControlClassesCompetition.py .\" Download this file onto the desktop of the drone Raspberry Pi, where you will be able to edit it in the future.  Step 1: Open a terminal session and edit the file /etc/profile  sudo nano /etc/profile  Step 2: Add the following line to the end of the file  python /home/pi/Desktop/DroneControlClassesCompetition.py   replace the script name and path with correct name and path of your start-up script.  Step 3: Save and Exit  Press  Ctrl+X  to exit nano editor followed by  Y  to save the file.", 
            "title": "Run a Python Script after login"
        }, 
        {
            "location": "/camera/", 
            "text": "Camera Trap\n\n\nHere is information about the camera trap compatible with the system. The current camera trap used is:\n\n\n\n\nBushnell TrophyCamera Brown\n\n\nModel 119736\n\n\n\n\nIn the previous version of the system, it was necessary to reset the internal circuitry of the camera trap before it works again. However, with Model 119736 it is not necessary to reset the camera after the USB disconnects.\n\n\nThe system may work with other camera traps beyond Bushnell Model 119736 if the camera trap continues functioning during/after the Raspberry Pi connects to it and downloads photos.", 
            "title": "Good camera traps to work with"
        }, 
        {
            "location": "/camera/#camera-trap", 
            "text": "Here is information about the camera trap compatible with the system. The current camera trap used is:   Bushnell TrophyCamera Brown  Model 119736   In the previous version of the system, it was necessary to reset the internal circuitry of the camera trap before it works again. However, with Model 119736 it is not necessary to reset the camera after the USB disconnects.  The system may work with other camera traps beyond Bushnell Model 119736 if the camera trap continues functioning during/after the Raspberry Pi connects to it and downloads photos.", 
            "title": "Camera Trap"
        }, 
        {
            "location": "/code_sleepy/", 
            "text": "Sleepy Pi 2 Code\n\n\n#include \nSleepyPi2.h\n\n#include \nTime.h\n\n#include \nLowPower.h\n\n#include \nPCF8523.h\n\n#include \nWire.h\n\n#include \nSoftwareSerial.h\n\n\n#define TIMEOUT_MSEC 300000\n#define CAMERA_ID String(\n002\n)\n#define FIRMWARE_VERSION String(\n0.3 Failsafe\n)\n\nint green = 6;\nint yellow = 5;\n\nSoftwareSerial xBeeSerial(9, 10); // Serial for Xbee RX, TX\n\nint dataIndex = 0;\nchar dataInputBuffer[32];\nchar valueBuffer[7];\nString ID = CAMERA_ID; //The ID of the Camera\nbool start;\nbool parse;\nbool readCommand;\nString command;\nint stringLength;\nString value;\nString iden;\nbool pi_running;\nunsigned long timeSinceLastContact;\n\n\nvoid setup() {\n  // Turn the Serial Protocol ON\n  Serial.begin(9600); //Serial communication to RasPi\n  while (!Serial) {\n    ; // wait for serial port to connect. Just in case\n  }\n  Serial.print(\nStarting camera trap Ardino firmware version: \n);\n  Serial.println(FIRMWARE_VERSION);\n\n  delay(50);\n\n  readCommand = false;\n  start = false;\n  parse = false;\n  xBeeSerial.begin(9600);\n\n  xBeeSerial.print(\nStarting camera trap Arduino firmware version: \n);\n  xBeeSerial.println(FIRMWARE_VERSION);\n\n  SleepyPi.enablePiPower(true);\n  pinMode(green, OUTPUT);\n  pinMode(yellow, OUTPUT);\n  timeSinceLastContact = millis();\n}\n\nvoid loop() {\n  SleepyPi.enableExtPower(true);\n  char  theChar;\n  command = \n; //reset command\n  value= \n; //reset value of command\n  iden=\n;\n\n  if (xBeeSerial.available()) {\n    theChar=xBeeSerial.read();\n    reader(start, parse, dataInputBuffer, theChar);\n    if (parse){\n      parser(iden,command,value,dataInputBuffer,dataIndex);\n      parse = false;\n      readCommand = true;\n    }\n  }\n\n  if (readCommand \n (iden == ID)){\n    timeSinceLastContact = millis();\n    xBeeSerial.print(\n%\n+ID+\n \n+command+\n \n+value+'\\r'+'\\n');\n\n    if (command == \nPOWR\n){\n      if (value == \n00000?\n){\n        pi_running = SleepyPi.checkPiStatus(false);\n        if (pi_running == true){\n          value = \n000001\n;\n        }\n        else {\n          value = \n000000\n;\n        }\n        xBeeSerial.print(\n%\n+ID+\n \n+command+\n \n+value+'\\r'+'\\n');\n      }\n      else if (value == \n000001\n){\n        startPi();\n      }\n      else if (value == \n000000\n) {\n        shutPi();\n      }\n    }\n\n    if (command == \nRSET\n){\n      resetCamera();\n    }\n    if (command == \nIDEN\n){\n      xBeeSerial.print(\n%\n+ID+\n \n+command+\n 000\n+ID+'\\r'+'\\n');\n    }\n    readCommand = false;\n  }\n\n  //timeot if no communication happened for a long time\n  if ((SleepyPi.checkPiStatus(false)) \n (millis()-timeSinceLastContact \n TIMEOUT_MSEC)) {\n    timeSinceLastContact=millis();\n    shutPi();\n  }\n\n  //reads from serial input and sends it via Xbee\n  if (Serial.available()){\n    xBeeSerial.write(Serial.read());\n  }\n\n}\n\n//function to turn on RaspberryPi\nvoid startPi (){\n  pi_running = SleepyPi.checkPiStatus(false);\n  if  (pi_running == false) {\n    SleepyPi.enablePiPower(true);\n    SleepyPi.enableExtPower(true);\n    delay(50);\n    Serial.println(\nOPEN PI\n);\n  }\n}\n//function to turn off RaspberryPi\nvoid shutPi (){\n  pi_running = SleepyPi.checkPiStatus(false);\n  if  (pi_running == true) {\n    SleepyPi.piShutdown(true);\n    SleepyPi.enableExtPower(true);\n    SleepyPi.enablePiPower(false);\n    delay(50);\n    Serial.println(\nSHDN PI\n);\n  }\n}\n\n//Parser function: Parse the data buffer into command, ID and value\nvoid parser (String \niden, String \ncommand, String \nvalue, char dataInputBuffer[], int stringLenth){\n  char valueBuffer[6] = {}; //max size of value is 6 bytes\n  int valueIndex = 0;\n\n  for (int x =1; x\n= stringLength; x++){\n    if (x\n4){ //Parse ID\n      iden = iden+dataInputBuffer[x];\n    }\n    else if (x\n9 \n x\n4){ //Parse command\n      command = command+dataInputBuffer[x];\n    }\n    else if ((dataInputBuffer[x]!=' ')){ //preprocess value\n      valueBuffer[valueIndex]=dataInputBuffer[x];\n      valueIndex++;\n    }\n  }\n  Serial.println(valueBuffer);\n  Serial.println(dataInputBuffer);\n  for (int c=0; c\n=5; c++){\n    if (valueBuffer[c]){ //parse value\n      value = value + valueBuffer[c];\n    }\n    else{ //prepend 0 to value for every NULL in valueBuffer\n      value = '0'+value;\n    }\n    Serial.println(value);\n  }\n  Serial.print(\nParser: Command is \n);\n  Serial.println(command);\n  Serial.print(\nParser: Value is \n);\n  Serial.println(value);\n  Serial.print(\nParser: ID is \n);\n  Serial.println(iden);\n}\n\n//Reader function: Starts appending incoming characters to a data buffer when ':' appears\nvoid reader (bool \nstart, bool \nparse, char dataInputBuffer[], char theChar){\n  if (theChar == ':'){ //start reading the string if the incoming byte is \n:\n\n    dataIndex = 0;\n    start = true;\n  }\n  if ((theChar == 0x0d)|| (theChar == 0x0a) || (dataIndex \n 31)){ // if incoming byte is CR then stop reading the string    // null terminate the string\n    stringLength = dataIndex;\n    if (dataIndex != 0){\n      parse = true;\n    }\n    dataIndex=0;\n    start = false;\n    Serial.println(\nReader: \n);\n  }\n  else if (theChar \n= 0x20 \n start){\n    dataInputBuffer[dataIndex]=theChar;\n    dataIndex++;\n  }\n}\n\nvoid resetCamera() {\n  pi_running = SleepyPi.checkPiStatus(false);\n  if (pi_running == true){\n    shutPi();\n  }\n  //masterOff();\n  //masterOn();\n  Serial.print(\nReset Camera\n);\n}\n\nvoid masterOn() {\n  turnSetup(green,yellow);\n  delay(50);\n  turnOff(green, yellow);\n  delay(50);\n  turnSetup(green,yellow);\n  delay(50);\n  turnOn(green, yellow);\n}\n\nvoid masterOff() {\n  turnSetup(green,yellow);\n  delay(50);\n  turnOff(green, yellow);\n}\n\nvoid masterSetup() {\n  turnSetup(green,yellow);\n}\n\nvoid turnOff(int green, int yellow) {\n  digitalWrite(green, HIGH);\n  digitalWrite(yellow, LOW); //default state of yellow is connected to COM\n}\n\nvoid turnOn(int green, int yellow) {\n  digitalWrite(green, LOW);\n  digitalWrite(yellow,LOW);\n}\n\nvoid turnSetup(int green, int yellow) {\n  digitalWrite(green, LOW);\n  digitalWrite(yellow, HIGH);\n}\n\n\n\n\n\nPython code\n\n\n#file to be loaded on RasPi@CameraTrap that backs up photos\n#camerabu = camera back up\n#loaded an option into sudo nano /etc/ssh/ssh_config and append ServerAliveInterval 60\n\nimport subprocess as sp\n\n\narg_backup = \n -avP --update --backup --backup-dir=backup --chmod=ugo=rwX --remove-source-files\n\ncamera_path = \n /media/usbhdd/DCIM/\n\nbackup_path = \n /home/pi/Desktop/BackUp/*\n\n\nstatus_makedirectory = sp.call(\nmkdir -v /home/pi/Desktop/BackUp/\n, shell=True)\nstatus_del = sp.call(\nrm -vr\n+ backup_path, shell=True)\nstatus_backup = sp.call(\nsudo rsync\n + arg_backup + camera_path + \n /home/pi/Desktop/BackUp/\n, shell=True)", 
            "title": "Code in the camera trap"
        }, 
        {
            "location": "/code_sleepy/#sleepy-pi-2-code", 
            "text": "#include  SleepyPi2.h \n#include  Time.h \n#include  LowPower.h \n#include  PCF8523.h \n#include  Wire.h \n#include  SoftwareSerial.h \n\n#define TIMEOUT_MSEC 300000\n#define CAMERA_ID String( 002 )\n#define FIRMWARE_VERSION String( 0.3 Failsafe )\n\nint green = 6;\nint yellow = 5;\n\nSoftwareSerial xBeeSerial(9, 10); // Serial for Xbee RX, TX\n\nint dataIndex = 0;\nchar dataInputBuffer[32];\nchar valueBuffer[7];\nString ID = CAMERA_ID; //The ID of the Camera\nbool start;\nbool parse;\nbool readCommand;\nString command;\nint stringLength;\nString value;\nString iden;\nbool pi_running;\nunsigned long timeSinceLastContact;\n\n\nvoid setup() {\n  // Turn the Serial Protocol ON\n  Serial.begin(9600); //Serial communication to RasPi\n  while (!Serial) {\n    ; // wait for serial port to connect. Just in case\n  }\n  Serial.print( Starting camera trap Ardino firmware version:  );\n  Serial.println(FIRMWARE_VERSION);\n\n  delay(50);\n\n  readCommand = false;\n  start = false;\n  parse = false;\n  xBeeSerial.begin(9600);\n\n  xBeeSerial.print( Starting camera trap Arduino firmware version:  );\n  xBeeSerial.println(FIRMWARE_VERSION);\n\n  SleepyPi.enablePiPower(true);\n  pinMode(green, OUTPUT);\n  pinMode(yellow, OUTPUT);\n  timeSinceLastContact = millis();\n}\n\nvoid loop() {\n  SleepyPi.enableExtPower(true);\n  char  theChar;\n  command =  ; //reset command\n  value=  ; //reset value of command\n  iden= ;\n\n  if (xBeeSerial.available()) {\n    theChar=xBeeSerial.read();\n    reader(start, parse, dataInputBuffer, theChar);\n    if (parse){\n      parser(iden,command,value,dataInputBuffer,dataIndex);\n      parse = false;\n      readCommand = true;\n    }\n  }\n\n  if (readCommand   (iden == ID)){\n    timeSinceLastContact = millis();\n    xBeeSerial.print( % +ID+   +command+   +value+'\\r'+'\\n');\n\n    if (command ==  POWR ){\n      if (value ==  00000? ){\n        pi_running = SleepyPi.checkPiStatus(false);\n        if (pi_running == true){\n          value =  000001 ;\n        }\n        else {\n          value =  000000 ;\n        }\n        xBeeSerial.print( % +ID+   +command+   +value+'\\r'+'\\n');\n      }\n      else if (value ==  000001 ){\n        startPi();\n      }\n      else if (value ==  000000 ) {\n        shutPi();\n      }\n    }\n\n    if (command ==  RSET ){\n      resetCamera();\n    }\n    if (command ==  IDEN ){\n      xBeeSerial.print( % +ID+   +command+  000 +ID+'\\r'+'\\n');\n    }\n    readCommand = false;\n  }\n\n  //timeot if no communication happened for a long time\n  if ((SleepyPi.checkPiStatus(false))   (millis()-timeSinceLastContact   TIMEOUT_MSEC)) {\n    timeSinceLastContact=millis();\n    shutPi();\n  }\n\n  //reads from serial input and sends it via Xbee\n  if (Serial.available()){\n    xBeeSerial.write(Serial.read());\n  }\n\n}\n\n//function to turn on RaspberryPi\nvoid startPi (){\n  pi_running = SleepyPi.checkPiStatus(false);\n  if  (pi_running == false) {\n    SleepyPi.enablePiPower(true);\n    SleepyPi.enableExtPower(true);\n    delay(50);\n    Serial.println( OPEN PI );\n  }\n}\n//function to turn off RaspberryPi\nvoid shutPi (){\n  pi_running = SleepyPi.checkPiStatus(false);\n  if  (pi_running == true) {\n    SleepyPi.piShutdown(true);\n    SleepyPi.enableExtPower(true);\n    SleepyPi.enablePiPower(false);\n    delay(50);\n    Serial.println( SHDN PI );\n  }\n}\n\n//Parser function: Parse the data buffer into command, ID and value\nvoid parser (String  iden, String  command, String  value, char dataInputBuffer[], int stringLenth){\n  char valueBuffer[6] = {}; //max size of value is 6 bytes\n  int valueIndex = 0;\n\n  for (int x =1; x = stringLength; x++){\n    if (x 4){ //Parse ID\n      iden = iden+dataInputBuffer[x];\n    }\n    else if (x 9   x 4){ //Parse command\n      command = command+dataInputBuffer[x];\n    }\n    else if ((dataInputBuffer[x]!=' ')){ //preprocess value\n      valueBuffer[valueIndex]=dataInputBuffer[x];\n      valueIndex++;\n    }\n  }\n  Serial.println(valueBuffer);\n  Serial.println(dataInputBuffer);\n  for (int c=0; c =5; c++){\n    if (valueBuffer[c]){ //parse value\n      value = value + valueBuffer[c];\n    }\n    else{ //prepend 0 to value for every NULL in valueBuffer\n      value = '0'+value;\n    }\n    Serial.println(value);\n  }\n  Serial.print( Parser: Command is  );\n  Serial.println(command);\n  Serial.print( Parser: Value is  );\n  Serial.println(value);\n  Serial.print( Parser: ID is  );\n  Serial.println(iden);\n}\n\n//Reader function: Starts appending incoming characters to a data buffer when ':' appears\nvoid reader (bool  start, bool  parse, char dataInputBuffer[], char theChar){\n  if (theChar == ':'){ //start reading the string if the incoming byte is  : \n    dataIndex = 0;\n    start = true;\n  }\n  if ((theChar == 0x0d)|| (theChar == 0x0a) || (dataIndex   31)){ // if incoming byte is CR then stop reading the string    // null terminate the string\n    stringLength = dataIndex;\n    if (dataIndex != 0){\n      parse = true;\n    }\n    dataIndex=0;\n    start = false;\n    Serial.println( Reader:  );\n  }\n  else if (theChar  = 0x20   start){\n    dataInputBuffer[dataIndex]=theChar;\n    dataIndex++;\n  }\n}\n\nvoid resetCamera() {\n  pi_running = SleepyPi.checkPiStatus(false);\n  if (pi_running == true){\n    shutPi();\n  }\n  //masterOff();\n  //masterOn();\n  Serial.print( Reset Camera );\n}\n\nvoid masterOn() {\n  turnSetup(green,yellow);\n  delay(50);\n  turnOff(green, yellow);\n  delay(50);\n  turnSetup(green,yellow);\n  delay(50);\n  turnOn(green, yellow);\n}\n\nvoid masterOff() {\n  turnSetup(green,yellow);\n  delay(50);\n  turnOff(green, yellow);\n}\n\nvoid masterSetup() {\n  turnSetup(green,yellow);\n}\n\nvoid turnOff(int green, int yellow) {\n  digitalWrite(green, HIGH);\n  digitalWrite(yellow, LOW); //default state of yellow is connected to COM\n}\n\nvoid turnOn(int green, int yellow) {\n  digitalWrite(green, LOW);\n  digitalWrite(yellow,LOW);\n}\n\nvoid turnSetup(int green, int yellow) {\n  digitalWrite(green, LOW);\n  digitalWrite(yellow, HIGH);\n}", 
            "title": "Sleepy Pi 2 Code"
        }, 
        {
            "location": "/code_sleepy/#python-code", 
            "text": "#file to be loaded on RasPi@CameraTrap that backs up photos\n#camerabu = camera back up\n#loaded an option into sudo nano /etc/ssh/ssh_config and append ServerAliveInterval 60\n\nimport subprocess as sp\n\n\narg_backup =   -avP --update --backup --backup-dir=backup --chmod=ugo=rwX --remove-source-files \ncamera_path =   /media/usbhdd/DCIM/ \nbackup_path =   /home/pi/Desktop/BackUp/* \n\nstatus_makedirectory = sp.call( mkdir -v /home/pi/Desktop/BackUp/ , shell=True)\nstatus_del = sp.call( rm -vr + backup_path, shell=True)\nstatus_backup = sp.call( sudo rsync  + arg_backup + camera_path +   /home/pi/Desktop/BackUp/ , shell=True)", 
            "title": "Python code"
        }, 
        {
            "location": "/code_rpi/", 
            "text": "Code on the drone\n\n\nimport serial\nimport os\nser = serial.Serial(\n/dev/ttyUSB0\n, 9600, timeout = 1)\nimport time\n\ncamera_ip_addr = [\n12\n,\n13\n]\n\nclass Command ():\n    def __init__(self,ID,command,value):\n        self.id = ID\n        self.command = command\n        self.value = value\n    def makeCommand (self):\n        if self.value == \n:\n            message = \n:\n+self.id+\n \n+self.command+\n0\n+\n\\r\\n\n #Added space here\n        else:\n            message = \n:\n+self.id+\n \n+self.command+\n \n+self.value+\n\\r\\n\n\n        return message\n    def writeCommand (self):\n        ser.write(self.makeCommand())\n\nclass Response():\n    def __init__(self,ID,command,value):\n        self.rawMessage = ser.readlines()\n        self.id = ID\n        self.command = command\n        self.value = value\n    def excludeGarbage(self):\n        notGarbage = []\n        returnMessage = self.rawMessage\n        #print \nRaw message is \n + str(returnMessage)\n        for i in returnMessage:\n            if \n%\n in i:\n                message = \n\n                read = False\n                for c in range(len(i)):\n                    if i[c] == \n%\n:\n                        read = True\n                    if i[c] == \n\\r\n or i[c] == \n\\n\n:\n                        read = False\n                    if read:\n                        message += i[c]\n                notGarbage.append(message)\n        return notGarbage\n#    def checkSum(self):\n#        message = self.excludeGarbage()\n#        for i in message:\n#            if len(i)!=\n    def readMessage(self):\n        messageDictList = []\n        messages = self.excludeGarbage()\n        for i in messages:\n            messageList = i.replace(\n%\n,\n).split(\n \n)\n            messageDict = {}\n            messageDict [\nID\n] = messageList [0]\n            messageDict [\ncommand\n] = messageList [1]\n            messageDict [\nvalue\n] = messageList [2]\n            messageDictList.append(messageDict)\n        return messageDictList\n    def checkEcho(self): #Check if the response matches the commmand\n        messageDictList = self.readMessage()\n        print(messageDictList)\n    for i in messageDictList:\n            messageDictList.remove(i)\n            if self.command == i [\ncommand\n] and self.value in i[\nvalue\n] and self.id == i [\nID\n]:\n                return messageDictList\n        return \nretry\n\n    def realResponse(self): #Dummy, Optimization (?)\n        message = self.checkEcho()\n        if message:\n            return message\n        else:\n            return None\n\ndef downloadFiles(ID): #Transfers files from camera trap to drone.\n# Rsync Arguments:\n#   -a       is equivalent to -rlptgoD, preserves everything recursion enabled\n#   -v       verbose\n#   -P       combines --partial (keeps partially transferred files) and --pro-\n#            gress (shows progress of transfer)\n#   --chmod  sets permissions; \na\n-for all:user/owner, group owner and all other users;\n#            \nrwx\n is read, write, execute rights\n#   --update This forces rsync to skip any files for which the destination file already\n#            exists and has a date later than the source file.\n    camera_trap_path = \n/media/usbhdd/DCIM/\n\n    usb_drive_path = \n/media/pi/B037-6D1A1/\n+str(ID)\n    rsync_command = \nrsync -avP --chmod=a=rwX --update pi@192.168.42.\n+camera_ip_addr[int(ID)-1]+\n:\n+camera_trap_path+\n \n+usb_drive_path\n    copy_files = sp.call(rsync_command, shell=True)\n    # make_backup = sp.call(\nssh -v pi@192.168.10.22 'python -v /home/pi/Desktop/camerabu.py'\n,shell=True)\n\n    return copy_files # if copy_files=0, then download was succesful\n\ndef POWR (ID, value):\n    message = Command(ID,\nPOWR\n,value)\n    message.writeCommand()\n    response = Response(ID,\nPOWR\n,value)\n    responseMessage = response.realResponse()\n    if responseMessage == \nretry\n:\n        ser.readlines()\n        return POWR(ID,value)\n    return responseMessage\n\ndef IDEN (ID, value=\n0\n):\n    message = Command(ID,\nIDEN\n,value)\n    message.writeCommand()\n    response = Response(ID,\nIDEN\n,value)\n    responseMessage = response.realResponse()\n    if responseMessage == \nretry\n:\n        return IDEN(ID)\n    return responseMessage\n\ndef RSET (ID, value=\n0\n):\n    message = Command(ID,\nRSET\n,value)\n    message.writeCommand()\n    response = Response(ID,\nRSET\n,value)\n    responseMessage = response.realResponse()\n    if responseMessage == \nretry\n:\n        return RSET(ID)\n    return responseMessage\n\ndef download_sequence(ID_list):\n    counter = 0\n    os.system(\nsudo mount /dev/sda1\n) #mounts USB flash drive into which photos are saved\n    for ID in ID_list:\n        ID = IDEN(ID)[0][\nID\n]\n          POWR (ID,\n1\n)\n        state = POWR (ID,\n?\n)\n        while state[0][\nvalue\n] != \n000001\n:\n            state = POWR(ID,\n?\n)\n\n        successful_download = downloadFiles(ID)\n\n        POWR (ID,\n0\n)\n          state = POWR (ID,\n?\n)\n        print(state)\n        while state[0] [\nvalue\n] != \n000000\n:\n            state = POWR (ID,\n?\n)\n        RSET(ID)\n        counter += 1\n        os.system(\nsudo umount /dev/sda1\n) #unmounts USB\n\nif __name__ == \n__main__\n:\n    ID_list = [\n001\n, \n002\n]\n    download_sequence(ID_list)", 
            "title": "Code in the drone"
        }, 
        {
            "location": "/code_rpi/#code-on-the-drone", 
            "text": "import serial\nimport os\nser = serial.Serial( /dev/ttyUSB0 , 9600, timeout = 1)\nimport time\n\ncamera_ip_addr = [ 12 , 13 ]\n\nclass Command ():\n    def __init__(self,ID,command,value):\n        self.id = ID\n        self.command = command\n        self.value = value\n    def makeCommand (self):\n        if self.value ==  :\n            message =  : +self.id+   +self.command+ 0 + \\r\\n  #Added space here\n        else:\n            message =  : +self.id+   +self.command+   +self.value+ \\r\\n \n        return message\n    def writeCommand (self):\n        ser.write(self.makeCommand())\n\nclass Response():\n    def __init__(self,ID,command,value):\n        self.rawMessage = ser.readlines()\n        self.id = ID\n        self.command = command\n        self.value = value\n    def excludeGarbage(self):\n        notGarbage = []\n        returnMessage = self.rawMessage\n        #print  Raw message is   + str(returnMessage)\n        for i in returnMessage:\n            if  %  in i:\n                message =  \n                read = False\n                for c in range(len(i)):\n                    if i[c] ==  % :\n                        read = True\n                    if i[c] ==  \\r  or i[c] ==  \\n :\n                        read = False\n                    if read:\n                        message += i[c]\n                notGarbage.append(message)\n        return notGarbage\n#    def checkSum(self):\n#        message = self.excludeGarbage()\n#        for i in message:\n#            if len(i)!=\n    def readMessage(self):\n        messageDictList = []\n        messages = self.excludeGarbage()\n        for i in messages:\n            messageList = i.replace( % , ).split(   )\n            messageDict = {}\n            messageDict [ ID ] = messageList [0]\n            messageDict [ command ] = messageList [1]\n            messageDict [ value ] = messageList [2]\n            messageDictList.append(messageDict)\n        return messageDictList\n    def checkEcho(self): #Check if the response matches the commmand\n        messageDictList = self.readMessage()\n        print(messageDictList)\n    for i in messageDictList:\n            messageDictList.remove(i)\n            if self.command == i [ command ] and self.value in i[ value ] and self.id == i [ ID ]:\n                return messageDictList\n        return  retry \n    def realResponse(self): #Dummy, Optimization (?)\n        message = self.checkEcho()\n        if message:\n            return message\n        else:\n            return None\n\ndef downloadFiles(ID): #Transfers files from camera trap to drone.\n# Rsync Arguments:\n#   -a       is equivalent to -rlptgoD, preserves everything recursion enabled\n#   -v       verbose\n#   -P       combines --partial (keeps partially transferred files) and --pro-\n#            gress (shows progress of transfer)\n#   --chmod  sets permissions;  a -for all:user/owner, group owner and all other users;\n#             rwx  is read, write, execute rights\n#   --update This forces rsync to skip any files for which the destination file already\n#            exists and has a date later than the source file.\n    camera_trap_path =  /media/usbhdd/DCIM/ \n    usb_drive_path =  /media/pi/B037-6D1A1/ +str(ID)\n    rsync_command =  rsync -avP --chmod=a=rwX --update pi@192.168.42. +camera_ip_addr[int(ID)-1]+ : +camera_trap_path+   +usb_drive_path\n    copy_files = sp.call(rsync_command, shell=True)\n    # make_backup = sp.call( ssh -v pi@192.168.10.22 'python -v /home/pi/Desktop/camerabu.py' ,shell=True)\n\n    return copy_files # if copy_files=0, then download was succesful\n\ndef POWR (ID, value):\n    message = Command(ID, POWR ,value)\n    message.writeCommand()\n    response = Response(ID, POWR ,value)\n    responseMessage = response.realResponse()\n    if responseMessage ==  retry :\n        ser.readlines()\n        return POWR(ID,value)\n    return responseMessage\n\ndef IDEN (ID, value= 0 ):\n    message = Command(ID, IDEN ,value)\n    message.writeCommand()\n    response = Response(ID, IDEN ,value)\n    responseMessage = response.realResponse()\n    if responseMessage ==  retry :\n        return IDEN(ID)\n    return responseMessage\n\ndef RSET (ID, value= 0 ):\n    message = Command(ID, RSET ,value)\n    message.writeCommand()\n    response = Response(ID, RSET ,value)\n    responseMessage = response.realResponse()\n    if responseMessage ==  retry :\n        return RSET(ID)\n    return responseMessage\n\ndef download_sequence(ID_list):\n    counter = 0\n    os.system( sudo mount /dev/sda1 ) #mounts USB flash drive into which photos are saved\n    for ID in ID_list:\n        ID = IDEN(ID)[0][ ID ]\n          POWR (ID, 1 )\n        state = POWR (ID, ? )\n        while state[0][ value ] !=  000001 :\n            state = POWR(ID, ? )\n\n        successful_download = downloadFiles(ID)\n\n        POWR (ID, 0 )\n          state = POWR (ID, ? )\n        print(state)\n        while state[0] [ value ] !=  000000 :\n            state = POWR (ID, ? )\n        RSET(ID)\n        counter += 1\n        os.system( sudo umount /dev/sda1 ) #unmounts USB\n\nif __name__ ==  __main__ :\n    ID_list = [ 001 ,  002 ]\n    download_sequence(ID_list)", 
            "title": "Code on the drone"
        }
    ]
}